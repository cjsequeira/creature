# Creature version 0.1.8 - README for developers

## System architecture

The Creature system architecture is inspired by [Redux](https://redux.js.org/), which itself is inspired by [Elm](https://guide.elm-lang.org/architecture/).

The Redux framework translates events (such as web page button clicks) to actions, which are then dispatched to reducers. Reducers update the app store, which is the application's state container. Updates to the app store trigger subscribed functions, such as UI rendering functions, in order to update the environment external to the app (e.g. the user's web browser view).
 
The Creature architecture features a **rulebook**: a data structure that describes the possible interactions between elements in the Creature simulation. The Creature rulebook is inspired by [Eric Lippert](https://ericlippert.com/2015/05/11/wizards-and-warriors-part-five/). In the Creature architecture, the rulebook takes a central role as a layer of logic between events and actions. The function of the rulebook is to convert events to actions based on the current application state. 

The Creature architecture also introduces the concept of a "simulator-generated event": an event generated by something happening in the world, such as a creature attempting to perform a certain behavior. Simulator-generated events are passed to the rulebook to create a set of actions. These actions could be (for example) to update a creature's data structure in the app store, or to remove a piece of food, or to add a message to the simulation journal, or more.

The Creature system adheres as much as possible to two important rules as observed in Redux and Elm:

1. NO STATE IN ACTION CREATORS: Action creators never rely on or even read the current application state. That is the job of separate logic - most notably the rulebook, which translates events to actions based on the current application state.
2. NO ACTIONS IN REDUCERS: Reducers never dispatch actions. This prevents unpredictable reducer behavior, rendering behavior, and app state changes. Action dispatching ALWAYS happens in separate code.

## Nested Arrow Functions
Nearly all multi-parameter functions in the Creature system are comma-separated functions, e.g.:

    export const preFuncTagTouchedFood = (storeType, randM_eventType) =>

This makes debugging easier. However, certain key functions are nested arrow functions, such as:

    export const randM_seededRand = (minFloatType, maxFloatType) => (seedIntType) =>
    export const physTypeDoPhysics = (storeType) => (physType) =>

In the first example, use of nested arrows make possible the construction of "generators" - for example:

    myGenerator = randM_seededRand(0.0, 1.0); 
    myRandM = myGenerator(seed);

The action **action_updateSelectPhysTypesRand** relies on just such a generator.

In the second example, use of nested arrows makes composition easy. Many functions that take storeType or physType as the first argument are nested arrow functions, enabling straightforward composition. For example:

    // function chain: must check wall collisions FIRST, because the check could
    //  adjust the acceleration/speed/heading used for movements
    pipe
        (
            physTypeCheckWallCollisions(storeType),
            physTypeDoMovements(storeType),
        )

        // apply the pipe to the given physType
        (physType);

## Monads

The Creature system rulebook features the use of two [monadic types](https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/)  called **randM** and **randMObj**. The purposes of these monadic types are to wrap an arbitrary datatype into a package along with a seed used for generating pseudo-random numbers. The **randMObj** type particularly supports objects containing multiple **randM** elements. 

The system rulebook consists almost entirely of monadic functions operating on **randM** arguments, allowing rules and support functions to use pseudo-random numbers at will. At the end of rulebook execution, an unwrapping function reveals the actions generated by the rulebook AS WELL AS an action to update the system seed to the appropriate value. The physTypeStore reducer features an action that uses **randMObj** to randomize specific physType parameters while tracking the changing seed.

## Complex data types:
### **physType**: The basic type for physical objects that act in the world

Example: creatures, rocks, whatever

All physType objects have two things in common: 

* a property called **act** with a function value implementing the physType's action. This function takes a **physType** as an argument and **always** returns a **physType**.
* a property called **conds**, which contains at least an **x** and a **y** coordinate representing the physType's location.

Description:

    physType: {
        ...
        act: physType => physType,
        conds: {
            x: float,
            y: float,
            ...
        }
    }

### **creatureType**, a specialty of **physType**: A type common to all creatures

All **creatureType** objects have the same properties found in **physType**, such as **act** and coordinates, plus a **behavior** string property in **conds**.

* Example behavior: 'eating'
* Example numerical condition: glucose_level

Description: 

    creatureType: {
        ...
        act: physType => physType,
        conds: {
            x: float,
            y: float,
            behavior: string,
            ...
        }
    }

### *Simple Creature*, a **creatureType** with glucose and neuro conditions

The *Simple Creature* is a **creatureType** with an **act** function of **actAsSimpleCreature** and two additional conditions:

* glucose, as float: The internal glucose level, between 0.0 and 100.0
* neuro, as float: The internal level of neurotransmitters, between 0.0 and 100.0

Description: 

    creatureType: {
        ...
        act: actAsSimpleCreature,
        conds: {
            x: float,
            y: float,
            behavior: string,
            glucose: float,
            neuro: float,
            ...
        }
    }

### **foodType**: A type for food - TO BE ADDED

### **desireFuncType**: A type for creature desire functions - TO BE ADDED

### **randGen**: The app's mutable random number generator - TO BE ADDED

### **storeType**: The application store data type - TO BE ADDED

### **journalType**: The type for the app journal - TO BE ADDED

### **actionType**: The type for Redux-like actions - TO BE ADDED

### **eventType**: The type for simulator-specific events - TO BE ADDED

### **behaviorBoxType**: The type for web page creature behavior boxes - TO BE ADDED

### Monadic types for use of immutable pseudo-random numbers - TO BE ADDED
