# Creature version 0.1.9 - README for developers

## System architecture

The Creature system architecture is inspired by [Redux](https://redux.js.org/), which itself is inspired by [Elm](https://guide.elm-lang.org/architecture/).

The Redux framework translates events (such as web page button clicks) to actions, which are then dispatched to reducers. Reducers update the app store, which is the application's state container. Updates to the app store trigger subscribed functions, such as UI rendering functions, in order to update the environment external to the app (e.g. the user's web browser view).
 
The Creature architecture features a **rulebook**: a data structure that describes the possible interactions between elements in the Creature simulation. The Creature rulebook is inspired by [Eric Lippert](https://ericlippert.com/2015/05/11/wizards-and-warriors-part-five/). In the Creature architecture, the rulebook takes a central role as a layer of logic between events and actions. The function of the rulebook is to convert events to actions based on the current application state. 

The Creature architecture also introduces the concept of a "simulator-generated event": an event generated by something happening in the world, such as a creature attempting to perform a certain behavior. Simulator-generated events are passed to the rulebook to create a set of actions. These actions could be (for example) to update a creature's data structure in the app store, or to remove a piece of food, or to add a message to the simulation journal, or more.

The Creature system adheres as much as possible to two important rules as observed in Redux and Elm:

1. NO STATE IN ACTION CREATORS: Action creators never rely on or even read the current application state. That is the job of separate logic - most notably the rulebook, which translates events to actions based on the current application state.
2. NO ACTIONS IN REDUCERS: Reducers never dispatch actions. This prevents unpredictable reducer behavior, rendering behavior, and app state changes. Action dispatching ALWAYS happens in separate code.

## Higher-Order Functions and Function Application
All multi-parameter functions in the Creature system are traditional JavaScript comma-separated functions, e.g.:

    export const preFuncTagTouchedFood = (storeType, randM_eventType) =>

This makes debugging easier than if multi-parameter functions were to be encoded as nested arrow functions. However, the Creature system also provides two functions for partial application, to support various aspects of functional programming. These functions return functions that permit the last argument to be given at a later time.

    // enclose one argument into the first slot of a COMMA-SEPARATED two-parameter function
    // takes:
    //  func: the two-parameter function to use, signature (any, any) => any
    //  arg1AnyType: the argument to enclose into the first slot, signature any
    // returns: a function of signature (any) => any
    export const partial2 = (func, arg1AnyType) =>
        (arg2AnyType) => func(arg1AnyType, arg2AnyType);

    // enclose two arguments into the first and second slots of a COMMA-SEPARATED three-parameter function
    // takes:
    //  func: the three-parameter function to use, signature (any, any, any) => any
    //  arg1AnyType: the argument to enclose into the first slot, signature any
    //  arg2AnyType: the argument to enclose into the second slot, signature any
    // returns: a function of signature (any) => any
    export const partial3 = (func, arg1AnyType, arg2AnyType) =>
        (arg3AnyType) => func(arg1AnyType, arg2AnyType, arg3AnyType);

 The Creature system also contains **compose** for composing two one-argument functions, as well as **pipe** and **pipe2** for flowing arguments through more than two functions.

    // compose two functions f and g of a specific one-parameter signature
    // takes:
    //  f: function of signature (typeA) => typeA
    //  g: function of signature (any) => typeA
    // returns: composed function of signature (any) => typeA
    export const compose = f => g =>
        anyType => f(g(anyType));

    // given a target, an array of ONE-PARAMETER functions, and an input argument of typeA,
    //  apply the first function to the input argument, then apply the next function to
    //  the result of the first function, and so on until all functions are applied
    // the array of functions will be completely flattened
    // ALL functions must be of signature (typeA) => typeA
    // takes:
    //  inputAnyType: input argument that functions apply to, as any
    //  funcs: array of functions to apply - will be applied LEFT TO RIGHT! (i.e. 0 to top index)
    // returns RESULT of signature typeA
    export const pipe = (inputAnyType, ...funcs) =>
        funcs.flat(Infinity).reduce((accumTypeA, thisFunc) => thisFunc(accumTypeA), inputAnyType);

    // given a "typeB", a target, and an array of COMMA-SEPARATED TWO-PARAMETER functions, 
    //  apply the first function to the target, then apply the 
    //  next function to the result of the first function, and so on until all 
    //  functions are applied
    // the array of functions will be completely flattened
    // first function must be of signature (typeB, any) => typeA
    // all remaining functions must be of signature (typeB, typeA) => typeA
    // takes:
    //  targetAnyType: target that functions apply to, as any
    //  funcs: array of functions to apply - will be applied LEFT TO RIGHT! (i.e. 0 to top index)
    // returns function of signature (typeB, any) => typeA
    export const pipe2 = (typeB, targetAnyType, ...funcs) =>
        funcs.flat(Infinity).reduce
            (
                (funcAccum, thisFunc) => thisFunc(typeB, funcAccum || targetAnyType),
                null
            );

The functions above are used in key parts of the Creature system. Note this example for Creature physics:

    ((eventType) =>
        pipe
            (
                // the given physType to be piped in, contained in eventType
                eventType.physType,
                [
                    // do laws of physics on physType above, using storeType as argument 1
                    // the pipe gives the physType to the partially-applied function below
                    partial2(physTypeDoPhysics, storeType),

                    // create a new event using the resulting physType from above
                    event_replacePhysType,
                ]
            )
    )

The **compose** function supports various aspects of the monads described below.

## Monads

The Creature system rulebook features the use of two [monadic types](https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/)  called **randM** and **randMObj**. The purposes of these monadic types are to wrap an arbitrary datatype into a package along with a seed used for generating pseudo-random numbers. The **randMObj** type particularly supports objects containing multiple **randM** elements. 

The system rulebook consists almost entirely of monadic functions operating on **randM** arguments, allowing rules and support functions to use pseudo-random numbers at will. At the end of rulebook execution, an unwrapping function reveals the actions generated by the rulebook AS WELL AS an action to update the system seed to the appropriate value. The physTypeStore reducer features an action that uses **randMObj** to randomize specific physType parameters while tracking the changing seed.

Key monad-supporting functions are below:

    // randM monad unit func
    // takes: 
    //  valAnyType: the value to wrap into randM
    // returns: randM with 0 seed
    // total signature: (any) => randM
    export const randM_unit = (valAnyType) =>
    ({
        [TYPE_RANDM]: true,
        value: valAnyType,
        nextSeed: 0,
    });

    // randM monad bind func
    // takes:
    //  func: the function to bind, of signature (any) => randM
    // returns function with signature (randM) => randM
    // total signature: (any => randM) => (randM => randM)
    export const randM_bind = (func) =>
        randM =>
        ({
            [TYPE_RANDM]: true,
            ...func(randM.value),
            nextSeed: randM.nextSeed,
        });

    // unit object func
    // builds a randMObj object by converting given prop-vals to randMs
    // takes: 
    //  objAnyType: the object to bundle randMs into
    //  objForRand: an object with numerical properties, as:
    //
    //  {
    //      property1: value1,
    //      property2: value2,
    //      ...
    //  }
    //  
    // returns randMObj object of:
    //  {
    //      ...objAnyType,
    //      ...{property1: randM1, property2: randM2, ...},
    //      nextSeed
    //  }
    export const randMObj_unit = (objAnyType, objForRand) =>
        // build an object out of entries
        Object.entries(objForRand).reduce(
            (accumProp, propValPair, i) => ({
                // object built so far
                ...accumProp,

                // the property to assign a randM to
                [propValPair[0]]:
                // the unit randM assigned to the property, using i to get the appropriate seed
                {
                    ...randM_unit(propValPair[1]),
                    nextSeed:
                        (
                            (i > 0)
                                ? randM_getNextSeed(0, i - 1)
                                : 0
                        )
                }
            }),
            // the initial object to accumulate upon, consisting of objAnyType and
            //  the next seed to be used
            {
                ...objAnyType,
                [TYPE_RANDM_OBJ]: true,
                nextSeed:
                    (
                        (Object.entries(objForRand).length > 1)
                            ? randM_getNextSeed(0, Object.entries(objForRand).length - 2)
                            : 0
                    )
            }
        );

    // randM lift func
    // takes:
    //  func: the function to lift, of signature (any) => any
    // returns function with signature (any) => randM
    // total signature: (any => any) => (any => randM)
    export const randM_lift = (func) =>
        anyType => compose(randM_unit)(func)(anyType);

    // randM func to lift and then bind
    // takes:
    //  func: the function to lift and then bind, of signature (any) => any
    // returns function with signature (randM) => randM
    // total signature: (any => any) => (randM => randM)
    export const randM_liftBind = (func) =>
        randM => compose(randM_bind)(randM_lift)(func)(randM);

In particular, **randM_liftBind** is used heavily in the rulebook to apply functions that do not perform random number generation and therefore do not care about the randM seed. For example:

    const leafPreservePhysType_func = (_, randM_eventType) =>
        // total signature: (randM_eventType) => randM_actionType
        randM_liftBind
            // replace the physType with the given physType
            // signature of this func: (eventType) => actionType or [actionType]
            ((eventType) => action_replacePhysType(eventType.physType))
            (randM_eventType);

## Complex data types:
### **physType**: The basic type for physical objects that act in the world

Example: creatures, rocks, whatever

All physType objects have two things in common: 

* a property called **act** with a function value implementing the physType's action. This function takes a **physType** as an argument and **always** returns a **physType**.
* a property called **conds**, which contains at least an **x** and a **y** coordinate representing the physType's location.

Description:

    physType: {
        ...
        act: physType => physType,
        conds: {
            x: float,
            y: float,
            ...
        }
    }

### **creatureType**, a specialty of **physType**: A type common to all creatures

All **creatureType** objects have the same properties found in **physType**, such as **act** and coordinates, plus a **behavior** string property in **conds**.

* Example behavior: 'eating'
* Example numerical condition: glucose_level

Description: 

    creatureType: {
        ...
        act: physType => physType,
        conds: {
            x: float,
            y: float,
            behavior: string,
            ...
        }
    }

### *Simple Creature*, a **creatureType** with glucose and neuro conditions

The *Simple Creature* is a **creatureType** with an **act** function of **actAsSimpleCreature** and two additional conditions:

* glucose, as float: The internal glucose level, between 0.0 and 100.0
* neuro, as float: The internal level of neurotransmitters, between 0.0 and 100.0

Description: 

    creatureType: {
        ...
        act: actAsSimpleCreature,
        conds: {
            x: float,
            y: float,
            behavior: string,
            glucose: float,
            neuro: float,
            ...
        }
    }

### **foodType**: A type for food - TO BE ADDED

### **desireFuncType**: A type for creature desire functions - TO BE ADDED

### **randGen**: The app's mutable random number generator - TO BE ADDED

### **storeType**: The application store data type - TO BE ADDED

### **journalType**: The type for the app journal - TO BE ADDED

### **actionType**: The type for Redux-like actions - TO BE ADDED

### **eventType**: The type for simulator-specific events - TO BE ADDED

### **behaviorBoxType**: The type for web page creature behavior boxes - TO BE ADDED

### Monadic types for use of immutable pseudo-random numbers - TO BE ADDED
