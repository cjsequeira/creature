# Creature version 0.1.4 - README for developers

## System architecture

The Creature system architecture is inspired by [Redux](https://redux.js.org/), which itself is inspired by [Elm](https://guide.elm-lang.org/architecture/).

The Redux framework translates events (such as web page button clicks) to actions, which are then dispatched to reducers. Reducers update the app store, which is the application's state container. Updates to the app store trigger subscribed functions, such as UI rendering functions, in order to update the environment external to the app (e.g. the user's web browser view).
 
The Creature architecture features a **rulebook**: a data structure that describes the possible interactions between elements in the Creature simulation. The Creature rulebook is inspired by [Eric Lippert](https://ericlippert.com/2015/05/11/wizards-and-warriors-part-five/). In the Creature architecture, the rulebook takes a central role as a layer of logic between events and actions. The function of the rulebook is to convert events to actions based on the current application state. 

The Creature architecture also introduces the concept of a "simulator-generated event": an event generated by something happening in the world, such as a creature attempting to perform a certain behavior. Simulator-generated events are passed to the rulebook to create a set of actions. These actions could be (for example) to update a creature's data structure in the app store, or to remove a piece of food, or to add a message to the simulation journal, or more.

The Creature system adheres as much as possible to two important rules as observed in Redux and Elm:

1. NO STATE IN ACTION CREATORS: Action creators never rely on or even read the current application state. That is the job of separate logic - most notably the rulebook, which translates events to actions based on the current application state.
2. NO ACTIONS IN REDUCERS: Reducers never dispatch actions. This prevents unpredictable reducer behavior, rendering behavior, and app state changes. Action dispatching ALWAYS happens in separate code.

## Monads

The Creature system rulebook features the use of a [monad](https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/) called **randM**. The purpose of this monad is to wrap an arbitrary datatype into a package along with a seed used for generating pseudo-random numbers. The system rulebook executes almost entirely within this monad, allowing rules and support functions to use pseudo-random numbers at will. At the end of rulebook execution, the monad is unwrapped into an action to update the system seed to the appropriate value.

## Complex data types:
### **physType**: The basic type for physical objects that act in the world

Example: creatures, rocks, whatever

All physType objects have two things in common: 

* a property called **act** with a function value implementing the physType's action. This function takes a **physType** as an argument and **always** returns a **physType**.
* a property called **conds**, which contains at least an **x** and a **y** coordinate representing the physType's location.

Description:

    physType: {
        ...
        act: physType => physType,
        conds: {
            x: float,
            y: float,
            ...
        }
    }

### **creatureType**, a specialty of **physType**: A type common to all creatures

All **creatureType** objects have the same properties found in **physType**, such as **act** and coordinates, plus a **behavior** string property in **conds**.

* Example behavior: 'eating'
* Example numerical condition: glucose_level

Description: 

    creatureType: {
        ...
        act: physType => physType,
        conds: {
            x: float,
            y: float,
            behavior: string,
            ...
        }
    }

### *Simple Creature*, a **creatureType** with glucose and neuro conditions

The *Simple Creature* is a **creatureType** with an **act** function of **actAsSimpleCreature** and two additional conditions:

* glucose, as float: The internal glucose level, between 0.0 and 100.0
* neuro, as float: The internal level of neurotransmitters, between 0.0 and 100.0

Description: 

    creatureType: {
        ...
        act: actAsSimpleCreature,
        conds: {
            x: float,
            y: float,
            behavior: string,
            glucose: float,
            neuro: float,
            ...
        }
    }

### **foodType**: A type for food - TO BE ADDED

### **desireFuncType**: A type for creature desire functions - TO BE ADDED

### **randGen**: The app's mutable random number generator - TO BE ADDED

### **storeType**: The application store data type - TO BE ADDED

### **journalType**: The type for the app journal - TO BE ADDED

### **actionType**: The type for Redux-like actions - TO BE ADDED

### **eventType**: The type for simulator-specific events - TO BE ADDED

### **randM, rand_eventType, rand_actionType **: Monadic types for use of immutable pseudo-random numbers - TO BE ADDED
